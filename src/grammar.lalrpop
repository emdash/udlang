// (C) 2021 Brandon Lewis
//
// LALRPOP grammar for the VM front-end.
//
// Expression grammar is adapted from the the `amath` crate, with heavy additions.
// https://github.com/vpzomtrrfrt/amath/blob/master/src/grammar.lalrpop

use crate::ast;
use crate::ast::{Node, ExprNode, TypeNode, StmtNode};
use crate::ast::Builder;
use std::str::FromStr;


grammar(ast: &Builder);


// Program Entry Point
pub Program: ast::Program = {
    Shebang? VersionDecl <Script>,
    VersionDecl <Library>
}


// For use as stand-alone shell script
Shebang: () = r"#.*\n";


// This is hard-coded for now. Later on this will be used to
// disambiguate or warn about incompatible languge versions.
VersionDecl: ()
  = "version" "0.2" ";";


// Scripts must declare their input and output types.
//
// Scripts cannot export type, value, or function definitions.
//
// The IO declarations divide the header from the body of a script.
//
// Side effects are allowed only within the script body.
Script: ast::Program
    = "script" <desc:Str> ";"
      <decls:Decl*>
      <i:InputDecl>
      <o:OutputDecl>
      <body:Expr>
    => ast.script(desc, &decls, i, o, body);


// Libraries may *not* contain IO declarations.
//
// Libraries must contain only type definitions, value definitions,
// function definitions, or exports declarations.
Library: ast::Program
    = "lib" <desc:Str> ";" <decls:LibDecl*>
    => ast.library(desc, &decls);


LibDecl: StmtNode = {
    Decl,
    Export
}


// Any statement which introduces lexical bindings, is a "declaration".
Decl: StmtNode = {
    Import,
    FuncDef,
    TypeDef,
    Let,
}


// This is what is allowed in a "primary" statement context. A
// "primary" statement context is one of the following:
// - inside a block, before the yielding expression.
// - a script body.
pub Statement: StmtNode = {
    FuncDef,
    TypeDef,
    Let,
}


// Expression entry point.
pub Expr: ExprNode = {
    BlockExpr,
    SimpleExpr,
}


// Type Entry Point
pub Type: TypeNode = TypeCons;


// Application of a type-level function: a type constructor.
pub TypeCons: TypeNode = {
    <cons:TypeCons> "<" <types:Comma<Type>> ">"
	=> Node::new(ast::TypeTag::TypeCons(cons, types.to_vec())),
    TypeTerm
}


// A primitive type, or a grouping of subtypes.
pub TypeTerm: TypeNode = {
    "Void"                      => ast.t_void.clone(),
    "Bool"                      => ast.t_bool.clone(),
    "Int"                       => ast.t_int.clone(),
    "Float"                     => ast.t_float.clone(),
    "Str"                       => ast.t_str.clone(),
    "Any"                       => ast.t_any.clone(),
    <TypeName>                  => ast.type_name(<>),
    "{" <Type> "}"              => ast.t_map(<>),
    "(" <Type> ")"              => <>,
    "<" <items:Comma<Type>> ">" => ast.tuple(&items),
    "[" <item:Type> "]"         => ast.t_list(item)
}


// Export some item from a library.
Export: StmtNode = {
    "export" <id:Id> ";"                => ast.export(id),
    "export" <t:TypeName> ";"           => ast.export(t),
    "export" <id:Id> "=" <val:Expr> ";" => ast.export_decl(ast.def(id, val)),
    "export" <fd:FuncDef>               => ast.export_decl(fd),
    "export" <td:TypeDef>               => ast.export_decl(td),
}


// Import a library, and / or items from a library.
Import: StmtNode
    = "import" <module:Id> <sel:("." <ImportSelector>)?> ";"
    => ast.import(module, sel);


// The different ways to select items from a library.
ImportSelector: ast::ImportSelector = {
    "_"                              => ast::ImportSelector::Itself,
    "*"                              => ast::ImportSelector::All,
    <item:Id>                        => ast.import_item(item),
    <item:Id> "as" <alias:Id>        => ast.import_alias(item, alias),
    <item:Id> "." <n:ImportSelector> => ast.import_nested(item, n),
    "{" <Comma<ImportSelector>> "}"  => ast.import_group(&<>)
}


// Syntactic sugar for defining a function returning a value.
FuncDef: StmtNode
    = "func" <name:Id> <args:Arglist> "->" <ret:Type> <body:BlockExpr>
    => ast.def(name, ast.lambda(&args, ret, body));


InputDecl: TypeNode
    = "input" <Type> ";" => <>;


OutputDecl: TypeNode
    = "output" <Type> ";" => <>;


// The only way to introduce a type binding
TypeDef: StmtNode
    = "type" <name:TypeName> ":" <t:Type> ";"
    => ast.typedef(name, t);


// Bind a name to a value.
Let: StmtNode
    = "let" <name:Id> "=" <value:Expr> ";"
    => ast.def(name, value);


// Any expression which is not a block.
SimpleExpr: ExprNode = {
    Lambda,
    Logic,
}


// Single paramater in a function signature
Param: (&'input str, TypeNode)
    = <name:Id> ":" <t:Type>
    => (name, t);

 
// The argument list of a function signature
Arglist: Vec<(&'input str, TypeNode)>
    = "(" <args:Comma<Param>> ")"
    => args;


// An anonymous function / procedure expression.
Lambda: ExprNode = {
    <args:Arglist> <ret:("->" <Type>)?> "=" <body:SimpleExpr>
	=> ast.lambda(
	    &args,
	    ret.unwrap_or(ast.t_any.clone()),
	    body
	),
    <args:Arglist> <ret:("->" <Type>)?> <body:BlockExpr>
	=> ast.lambda(
	    &args,
	    ret.unwrap_or(ast.t_any.clone()),
	    body
	),
}


// A sequence of statements with a trailing expression.
//
// This trailing expression is *not* optional in an expression
// context.
BlockExpr: ExprNode = {
    "{" <stmts:Statement*> <ret:Expr> "}"
        => ast.block(&stmts, ret),
}


// sloppily-parenthesized logic hould do the least surprising thing.
Logic: ExprNode = {
    <a:Logic> "and" <b:Rel> => ast.bin(ast::BinOp::And, a, b),
    <a:Logic> "or"  <b:Rel> => ast.bin(ast::BinOp::Or, a, b),
    <a:Logic> "xor" <b:Rel> => ast.bin(ast::BinOp::Xor, a, b),
    Rel
}


// sloppily-parenthesized relational operators should also do the
// least surprising thing.
Rel: ExprNode = {
    <a:Rel> "<"  <b:Sum> => ast.bin(ast::BinOp::Lt, a, b),
    <a:Rel> ">"  <b:Sum> => ast.bin(ast::BinOp::Gt, a, b),
    <a:Rel> "<=" <b:Sum> => ast.bin(ast::BinOp::Lte, a, b),
    <a:Rel> ">=" <b:Sum> => ast.bin(ast::BinOp::Gte, a, b),
    <a:Rel> "==" <b:Sum> => ast.bin(ast::BinOp::Eq, a, b),
    Sum
};


Sum: ExprNode = {
    <a:Sum> "+" <b:Factor> => ast.bin(ast::BinOp::Add, a, b),
    <a:Sum> "-" <b:Factor> => ast.bin(ast::BinOp::Sub, a, b),
    Factor,
};


Factor: ExprNode = {
    <a:Factor> "*" <b:Exp> => ast.bin(ast::BinOp::Mul, a, b),
    <a:Factor> "/" <b:Exp> => ast.bin(ast::BinOp::Div, a, b),
    Exp
};


Exp: ExprNode = {
    <base:Exp> "^" <exp: InvTerm> => ast.bin(ast::BinOp::Pow, base, exp),
    InvTerm
}


// We want these unary operators applied to a function call to do the
// right thing. I.e. -foo() should parse as (- (foo)), not ((- foo)).
//
// The same thing applies to logical negation.
InvTerm: ExprNode = {
    "-" <a:InvTerm> => ast.un(ast::UnOp::Neg, a),
    "not" <a:InvTerm> => ast.un(ast::UnOp::Not, a),
    Call
};


// We want indexing and selection to bind before function calls, so that
// foo.bar(a) parses as ((dot foo bar) a), not (dot foo (bar a))
Call: ExprNode = {
    <func:Call> "(" <args:Args> ")" => ast.call(func, &args),
    <obj:Call> "." <id:Id> => ast.dot(obj, id),
    <obj:Call> "[" <e:Expr> "]" => ast.index(obj, e),
    Term
}


// Literals of any type except lambdas.
Term: ExprNode = {
    "in" => ast.in_.clone(),
    Id => ast.id(<>),
    Int => ast.i(<>),
    Float => ast.f(<>),
    Str => ast.s(<>),
    Boolean => ast.b(<>),
    "(" <a:Expr> ")" => a,
    "[" <l:Comma<Expr>> "]" => ast.list(&l),
    "{" <m:MapItems> "}" => ast.map(&m),
};


// A single item in a map.
MapItem: (&'input str, ExprNode) = {
    <k:Str> ":" <v:Logic> => (k, v),
    <k:Id> ":" <v:Logic> => (k, v)
}


// Function call arguments
Args: Vec<ExprNode> = Comma<Arg>;


// Either an argument or a placeholder for partial application.
Arg: ExprNode = {
    Expr,
    "$" => ast.partial.clone()
}


// So far only used in maps.
MapItems = Comma<MapItem>;


// Comma-separated lists of things.
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}


// Semicolon-separated lists of things.
Semicolon<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}


// Terminals
Int: i64              = r"-?[0-9]+" => i64::from_str(<>).unwrap();
Float: f64            = r"-?[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap();
Id: &'input str       = r"[a-z_][A-Za-z0-9_]*" => <>;
TypeName: &'input str = r"[A-Z][A-Za-z0-9_]*" => <>;
Boolean: bool         = {"true" => true, "false" => false};
Str: &'input str      = <s:r#""(([^\\"]|\\.)*)""#> => &s[1..(s.len() - 1)];


match {
    // Skip whitespace and comments.
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { },
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
} else {
    _
}
