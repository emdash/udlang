// LALRPOP grammar for the VM front-end.
//
// Adapted from that found in the `amath` crate, with heavy additions.
// https://github.com/vpzomtrrfrt/amath/blob/master/src/grammar.lalrpop

use crate::ast;
use crate::ast::Node;
use crate::ast::Builder;
use std::str::FromStr;


grammar(ast: &Builder);


// Program Entry Point
pub Program: ast::Seq<ast::Statement>
    = "Version" ":" ".1-alpha" ";" <Statement*>;


// Statement entry point.
pub Statement: Node<ast::Statement> = {
    FuncDef,
    ProcDef,
    TypeDef,
    Effect,
    Let,
    EffectExpr,
    Iteration,
}


// Expression entry point.
pub Expr: Node<ast::Expr> = {
    Block,
    SimpleExpr
}


// Type Entry Point
pub Type: Node<ast::TypeTag> = TypeExpr;


// Syntactic sugar for Union(a, b)
pub TypeExpr: Node<ast::TypeTag> = {
    <a:TypeExpr> "|" <b:TypeCons> => ast.union(&[a, b]),
    // If we had a Sum type, it would go here, and would look like this.
    // <a:TypeExpr> "+" <b:TypeCons> => ast.sum(&[a, b]),
    <TypeCons>   "?"              => ast.option(<>),
    TypeCons,
}


// Application of a type-level function: a type constructor.
pub TypeCons: Node<ast::TypeTag> = {
    <cons:TypeCons> "<" <types:Comma<Type>> ">"
	=> Node::new(ast::TypeTag::TypeCons(cons, types.to_vec())),
    TypeTerm
}


// A primitive type, or a grouping of subtypes.
pub TypeTerm: Node<ast::TypeTag> = {
    "Void"                      => ast.t_void.clone(),
    "Bool"                      => ast.t_bool.clone(),
    "Int"                       => ast.t_int.clone(),
    "Float"                     => ast.t_float.clone(),
    "Str"                       => ast.t_str.clone(),
    "Point"                     => ast.t_point.clone(),
    "Self"                      => ast.t_this.clone(),
    <TypeName>                  => ast.type_name(<>),
    <Record>                    => <>,
    "(" <Type> ")"              => <>,
    "<" <items:Comma<Type>> ">" => ast.tuple(&items),
    "[" <item:Type> "]"         => ast.t_list(item)
}


// Record types
pub Record: Node<ast::TypeTag>
    = "{" <members:Semicolon<Member>> "}"
    => ast.record(&members);


// Any field in a record type.
pub Member: (&'input str, ast::Member) = {
    "field" <name:Id> ":" <t:Type>
	=> ast.field(name, t),
    "method" <name:Id> <args:Arglist> "->" <ret:Type> "=" <body:Expr>
	=> ast.method(name, &args, ret, body),
    "const" <name:Id> ":" <t:Type> "=" <value:Expr>
	=> ast.static_val(name, t, value),
    "static" <name:Id> <args:Arglist> "->" <ret:Type> "=" <body:Expr>
	=> ast.static_method(name, &args, ret, body),
}


// Syntactic sugar for defining a function returning a value.
FuncDef: Node<ast::Statement>
    = "func" <name:Id> <args:Arglist> "->" <ret:Type> <body:Block>
    => ast.def(name, ast.lambda(&args, ret, body));


// Syntatic sugar for defining a function which returns no value.
ProcDef: Node<ast::Statement>
    = "proc" <name:Id> <args:Arglist> <body:Block>
    => ast.def(name, ast.lambda(&args, ast.t_void.clone(), body));


// Syntactic sugar for defining a template function.
//
// This is desugared to an extra function arg that is folded into the
// argument list, allowing `delegate` to be in-scope within the
// template's body.
//
// Templates can be called with the TemplateCall syntax, which
// consumes a trailing block. This allows defining library functions
// which feel like control structures.
TemplateDef: Node<ast::Statement>
    = "template" <name:Id> <args:Arglist> "using" <delegate:Id> <body:Block>
    => ast.def(name, ast.template(&args, delegate, body));


// The only way to introduce a type binding
TypeDef: Node<ast::Statement>
    = "type" <name:TypeName> ":" <t:Type> ";"
    => ast.typedef(name, t);


// Used for raw cairo operations.
Effect: Node<ast::Statement>
    = "out" <name:Id> <exprs:ExprList> ";"
    => ast.emit(name, &exprs);


// Bind a name to a value.
Let: Node<ast::Statement>
    = "let" <name:Id> "=" <value:Expr> ";"
    => ast.def(name, value);


// An expression evaluated for its side effects in a statement context.
//
// To keep the LALRPOP happy, this is a subset of expressions.
EffectExpr: Node<ast::Statement> = {
    <Cond> => ast.expr_for_effect(<>),
    TemplateCall,
}


// Iterate over a collection.
Iteration: Node<ast::Statement> = {
    "for" <name:Id> "in" <list:Expr> <body:Block>
	=> ast.list_iter(name, list, ast.expr_for_effect(body)),
    "for" "(" <key:Id> "," <value:Id> ")" "in" <map:Expr> <body:Block>
	=> ast.map_iter(key, value, map, ast.expr_for_effect(body))
}


// Any expression which is not a Block.
//
// Needed to avoid the abiguity of nesting blocks.
SimpleExpr: Node<ast::Expr> = {
    Lambda,
    Cond,
    Logic,
}


// An if-else chain
Cond: Node<ast::Expr>
    = "if"
      <first:CondClause>
      <rest:("elif" <CondClause>)*>
      <default:("else" <Block>)?>
    => {
        let mut clauses = vec!{first};
        clauses.extend(rest);
        ast.cond(clauses.as_slice(), default.unwrap_or(ast.void.clone()))
    }
;


// Single clause in an if-else chain
CondClause: (Node<ast::Expr>, Node<ast::Expr>)
    = "(" <pred: Expr> ")" <body: Block>
    => (pred, body);


// Single paramater in a function signature
Param: (&'input str, Node<ast::TypeTag>)
    = <name:Id> ":" <t:Type>
    => (name, t);


// The argument list of a function signature
Arglist: Vec<(&'input str, Node<ast::TypeTag>)>
    = "(" <args:Comma<Param>> ")"
    => args;


// An anonymous function expression.
Lambda: Node<ast::Expr>
    = <args:Arglist> <ret:("->" <Type>)?> "=" <body:Expr>
    => ast.lambda(
	&args,
	ret.unwrap_or(ast.t_void.clone()),
	body
    );


// A sequence of statements treated as an expression.
//
// If the `yield` keyword is present, then this block has a value.
Block: Node<ast::Expr> = {
    "{" <stmts:Statement+> <ret:("yield" <SimpleExpr>)?> "}"
        => ast.block(&stmts, ret.unwrap_or(ast.void.clone())),
    "{" <ret:("yield" <SimpleExpr>)> "}"
	=> ret,
}


// Expression entry point anow, this is the logic operators. This way
// sloppily-parenthesized logic hould do the least surprising thing.
Logic: Node<ast::Expr> = {
    <a:Logic> "and" <b:Rel> => ast.bin(ast::BinOp::And, a, b),
    <a:Logic> "or"  <b:Rel> => ast.bin(ast::BinOp::Or, a, b),
    <a:Logic> "xor" <b:Rel> => ast.bin(ast::BinOp::Xor, a, b),
    Rel
}


// Relational operators are the next highest precedence.
Rel: Node<ast::Expr> = {
    <a:Rel> "<"  <b:Sum> => ast.bin(ast::BinOp::Lt, a, b),
    <a:Rel> ">"  <b:Sum> => ast.bin(ast::BinOp::Gt, a, b),
    <a:Rel> "<=" <b:Sum> => ast.bin(ast::BinOp::Lte, a, b),
    <a:Rel> ">=" <b:Sum> => ast.bin(ast::BinOp::Gte, a, b),
    <a:Rel> "==" <b:Sum> => ast.bin(ast::BinOp::Eq, a, b),
    Sum
};


Sum: Node<ast::Expr> = {
    <a:Sum> "+" <b:Factor> => ast.bin(ast::BinOp::Add, a, b),
    <a:Sum> "-" <b:Factor> => ast.bin(ast::BinOp::Sub, a, b),
    Factor,
};


Factor: Node<ast::Expr> = {
    <a:Factor> "*" <b:Exp> => ast.bin(ast::BinOp::Mul, a, b),
    <a:Factor> "/" <b:Exp> => ast.bin(ast::BinOp::Div, a, b),
    Exp
};


Exp: Node<ast::Expr> = {
    <base:Exp> "^" <exp: InvTerm> => ast.bin(ast::BinOp::Pow, base, exp),
    InvTerm
}


// We want these unary operators applied to a function call to do the
// right thing. I.e. -foo() should parse as (- (foo)), not ((- foo)).
//
// The same thing applies to logical negation.
InvTerm: Node<ast::Expr> = {
    "-" <a:InvTerm> => ast.un(ast::UnOp::Neg, a),
    "not" <a:InvTerm> => ast.un(ast::UnOp::Not, a),
    Call
};


// Allow a function call to consume a trailing block in a statement context.
//
// Concept Inspired by OpenScad and Ruby. The block just gets folded
// into the arguments.
//
// To simplify the grammar, templates are assumed not to return a
// value and are purely used for their effects.
TemplateCall: Node<ast::Statement> = {
    <func:Selection> "(" <args:ExprList> ")" <delegate:Block>
	=> ast.template_call(func, &args, delegate),
    <func:Selection> "(" <args:ExprList> ")" ";"
        => ast.expr_for_effect(ast.call(func, &args))
};


// We want indexing and selection to bind before function calls, so that
// foo.bar(a) parses as ((dot foo bar) a), not (dot foo (bar a))
Call: Node<ast::Expr> = {
    <func:Call> "(" <args:ExprList> ")" => ast.call(func, &args),
    Selection
}


// XXX: see github issue #13
Selection: Node<ast::Expr> = {
    <obj:Selection> "." <id:Id> => ast.dot(obj, id),
    <obj:Selection> "[" <e:Expr> "]" => ast.index(obj, e),
    Term
}


// Literals of any type except lambdas.
Term: Node<ast::Expr> = {
    "self" => ast.this.clone(),
    Id => ast.id(<>),
    Int => ast.i(<>),
    Float => ast.f(<>),
    Str => ast.s(<>),
    Boolean => ast.b(<>),
    "(" <a:Expr> ")" => a,
    "[" <l:ExprList> "]" => ast.list(&l),
    "{" <m:MapItems> "}" => ast.map(&m),
};


// A single item in a map.
MapItem: (&'input str, Node<ast::Expr>) = {
    <k:Str> ":" <v:Logic> => (k, v),
    <k:Id> ":" <v:Logic> => (k, v)
}


// Any commma-separated list of values.
ExprList = Comma<Expr>;


// So far only used in maps.
MapItems = Comma<MapItem>;


// Comma-separated lists of things.
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}


// Semicolon-separated lists of things.
Semicolon<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}


// Terminals
Int: i64              = r"-?[0-9]+" => i64::from_str(<>).unwrap();
Float: f64            = r"-?[0-9]+\.[0-9]+" => f64::from_str(<>).unwrap();
Id: &'input str       = r"[a-z_][A-Za-z0-9_]*" => <>;
TypeName: &'input str = r"[A-Z][A-Za-z0-9_]*" => <>;
Boolean: bool         = {"true" => true, "false" => false};
Str: &'input str      = <s:r#""(([^\\"]|\\.)*)""#> => &s[1..(s.len() - 1)];
